# JavaScript Data Structures: Arrays, Objects, and Maps

## Arrays: Powerful Collections

### Creating Arrays
```javascript
// Multiple ways to create arrays
let fruits = ['apple', 'banana', 'orange'];
let emptyArray = [];
let mixedArray = [1, 'two', true, { name: 'John' }];

// Advanced array creation
let numbersArray = Array.from({ length: 5 }, (_, index) => index + 1);
let copiedArray = [...fruits];
```

### Key Array Methods
```javascript
let numbers = [1, 2, 3, 4, 5];

// Transformation
let doubled = numbers.map(num => num * 2);
let filtered = numbers.filter(num => num > 2);
let reduced = numbers.reduce((sum, num) => sum + num, 0);

// Manipulation
numbers.push(6);       // Add to end
numbers.pop();         // Remove from end
numbers.unshift(0);    // Add to beginning
numbers.shift();       // Remove from beginning
```

### Iterating Arrays
```javascript
let fruits = ['apple', 'banana', 'orange'];

// Multiple iteration techniques
fruits.forEach(fruit => console.log(fruit));
for (let fruit of fruits) console.log(fruit);
let upperFruits = fruits.map(fruit => fruit.toUpperCase());
```

### Multidimensional Arrays
```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

// Nested iteration
matrix.forEach(row => {
  row.forEach(cell => console.log(cell));
});
```

## Objects: Structured Data Containers

### Creating Objects
```javascript
// Object literal
let person = {
  firstName: 'John',
  lastName: 'Doe',
  fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
};

// Object methods
Object.keys(person);       // Get keys
Object.values(person);     // Get values
Object.entries(person);    // Get key-value pairs
```

### Object Destructuring
```javascript
let { firstName, lastName } = person;
let { firstName: name } = person;  // Renaming
let { ...rest } = person;          // Rest operator
```

## Maps: Advanced Key-Value Storage

### Creating and Using Maps
```javascript
// Map initialization
let userRoles = new Map();
userRoles.set('John', 'Admin');
userRoles.set('Alice', 'User');

// Map operations
console.log(userRoles.get('John'));     // 'Admin'
console.log(userRoles.has('Alice'));    // true
userRoles.delete('John');

// Iterating Maps
for (let [user, role] of userRoles) {
  console.log(`${user}: ${role}`);
}
```

### Map vs Object
```javascript
// Map advantages
let map = new Map();
let obj = {};

// Maps allow any type of key
map.set(1, 'number key');
map.set('1', 'string key');
map.set({}, 'object key');

// Easy size tracking
console.log(map.size);  // Number of entries

// Iteration is straightforward
map.forEach((value, key) => console.log(key, value));
```

## Advanced Techniques

### Combining Data Structures
```javascript
let users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Alice' }
];

let userMap = new Map(users.map(user => [user.id, user]));
console.log(userMap.get(1));  // { id: 1, name: 'John' }
```

## Best Practices
- Use `const` for arrays and objects when possible
- Prefer `Map` for key-value storage with complex keys
- Use destructuring for cleaner code
- Leverage array methods for transformations
- Avoid mutation when possible

## Performance Considerations
- Arrays: Fast for ordered, indexed data
- Objects: Best for structured, named properties
- Maps: Ideal for frequent additions/removals of key-value pairs

## Conclusion
Understanding these data structures enables writing more efficient and readable JavaScript code. Choose the right structure based on your specific use case.

## Arrays: Advanced Methods and Techniques

### Comprehensive Array Methods

```javascript
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Transformation Methods
let doubled = numbers.map(num => num * 2);           // Transform each element
let evenNumbers = numbers.filter(num => num % 2 === 0); // Filter elements
let sum = numbers.reduce((acc, num) => acc + num, 0);   // Reduce to single value

// Search and Validation Methods
let hasEven = numbers.some(num => num % 2 === 0);    // Check if any element matches
let allPositive = numbers.every(num => num > 0);     // Check if all elements match
let foundNumber = numbers.find(num => num > 5);      // Find first matching element
let indexOfNumber = numbers.findIndex(num => num > 5); // Find index of first match

// Array Searching
let index = numbers.indexOf(5);                      // Find index of element
let includes = numbers.includes(3);                  // Check if element exists

// Sorting and Ordering
let sorted = numbers.sort((a, b) => a - b);          // Numeric sorting
let reversed = numbers.reverse();                    // Reverse array

// Slicing and Combining
let sliced = numbers.slice(2, 5);                    // Extract portion of array
let concatenated = numbers.concat([11, 12, 13]);     // Combine arrays

// Advanced Manipulation
let flattened = [[1, 2], [3, 4], [5, 6]].flat();     // Flatten nested arrays
```

### Advanced Array Techniques

```javascript
// Grouping and Reducing
let people = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 },
  { name: 'Charlie', age: 25 }
];

// Grouping by a property
let groupedByAge = people.reduce((acc, person) => {
  (acc[person.age] = acc[person.age] || []).push(person);
  return acc;
}, {});

// Unique Values
let uniqueAges = [...new Set(people.map(p => p.age))];

// Chaining Methods
let processedPeople = people
  .filter(p => p.age > 25)
  .map(p => p.name.toUpperCase())
  .sort();
```

### Spread and Rest Operators

```javascript
// Spread Operator
let original = [1, 2, 3];
let extended = [...original, 4, 5];  // [1, 2, 3, 4, 5]

// Rest Parameter in Functions
function sumAll(...numbers) {
  return numbers.reduce((sum, num) => sum + num, 0);
}
console.log(sumAll(1, 2, 3, 4)); // 10

// Destructuring with Rest
let [first, ...rest] = [1, 2, 3, 4, 5];
console.log(rest); // [2, 3, 4, 5]
```

### Performance Considerations

```javascript
// Efficient Array Operations
let largeArray = Array.from({ length: 1000000 }, (_, i) => i);

// Prefer for...of for iteration
for (let num of largeArray) {
  // More performant than .forEach()
}

// Avoid frequent array mutations
// Use methods that return new arrays instead of modifying original
```

## Best Practices

1. Use immutable methods when possible
2. Prefer `const` for array declarations
3. Use appropriate method for the task
   - `map()` for transformations
   - `filter()` for selections
   - `reduce()` for aggregations
4. Be cautious with nested array methods
5. Consider performance for large arrays

## Common Pitfalls

```javascript
// Beware of these common mistakes
let numbers = [1, 2, 3];

// Mutation vs Non-Mutation
numbers.push(4);       // Mutates original array
let newNumbers = [...numbers, 4];  // Creates new array

// Sorting Gotchas
let mixed = [10, 2, 30, 4];
mixed.sort();  // [10, 2, 30, 4] - Lexicographic sorting
mixed.sort((a, b) => a - b);  // [2, 4, 10, 30] - Numeric sorting
```

## Conclusion

Mastering array methods allows for more declarative, readable, and efficient JavaScript code. Choose the right method for your specific use case, and always consider performance and readability.


```js
// Destructuring with Objects and Arrays

// Object with nested array
let student = {
  name: 'Alice',
  age: 22,
  courses: ['Math', 'Physics', 'Computer Science'],
  address: {
    city: 'New York',
    zipCode: '10001'
  }
};

// Destructuring object properties and nested array
let { name, age, courses, address: { city, zipCode } } = student;

console.log(name); // Output: Alice
console.log(age); // Output: 22
console.log(courses); // Output: ['Math', 'Physics', 'Computer Science']
console.log(city); // Output: New York
console.log(zipCode); // Output: 10001

// Array of objects
let employees = [
  { id: 1, name: 'John', position: 'Developer' },
  { id: 2, name: 'Emma', position: 'Designer' },
  { id: 3, name: 'Mike', position: 'Manager' }
];

// Destructuring array elements (objects)
let [{ id: empId1, name: empName1, position: empPosition1 }, , { id: empId3, name: empName3 }] = employees;

console.log(empId1, empName1, empPosition1); // Output: 1 John Developer
console.log(empId3, empName3); // Output: 3 Mike
```